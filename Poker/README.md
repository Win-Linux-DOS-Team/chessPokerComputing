## Poker

本目录提供扑克游戏可能的实现。

### poker.cpp

这是一个你能打赢，同时支持多种扑克游戏的 C++ 程序。

该代码支持命令行启动，在 Windows 下应当使用 Visual Studio 进行静态编译，在其它平台下可使用 g++ 直接编译，要求编译器最低支持 C++11 标准。

基类成员变量：

```
protected:
	mt19937 seed{}; // 用于存储随机数种子
	string name = "扑克牌"; // 用于存储扑克牌类型
	Values values{}; // 用于存储大小
	vector<vector<Card>> players{}; // 用于存储玩家手上的扑克牌
	vector<Card> deck{}; // 用于存储地主牌或牌堆
	vector<vector<Hand>> records{}; // 用于存储游戏记录
	Player currentPlayer = INVALID_PLAYER, dealer = INVALID_PLAYER; // 分别用于指示当前需要进行操作和首轮第一位出牌的玩家
	Hand lastHand{}; // 用于存储最后一手非空 hand
	vector<Amount> amounts{}; // 用于存储结算信息
	Status status = Status::Ready; // 用于存储状态
```

基类中主要的函数（所有成员函数的返回值类型均为 bool）：

1) 构造函数：初始化随机数种子，派生类的构造函数中应当调用该过程并声明扑克牌类型；该过程仅在实例创建时被调用；调用成功后，状态将变更为缺省值 Ready。
2) 析构函数：该过程仅在实例的销毁阶段被调用；由于实例即将被销毁，状态变更没有意义，故不会发生状态变更。
3) initialize：初始化 values（从 1 开始）和 players，该过程将清空 deck 和 record；该过程允许在不低于 Ready 的状态（可理解为任意状态）下被调用；调用成功后，状态将变更为 Initialized。
4) deal：发牌，该过程将利用随机数种子 seed 向 players 和 deck 随机分配扑克牌并清空 records，随后将预备回合信息写入 records[0]；该过程允许在不低于 Initialized 的状态下被调用；调用成功后，状态将变更为 Dealt（涉及地主信息）或 Assigned（不涉及地主信息）；
5) 一些为获取当前玩家和地主信息设定设立的额外函数：地主信息设定仅允许在 Dealt 状态下涉及地主信息的扑克牌类型中进行；地主信息被写入 records[0] 后，状态将变更为 Assigned。
6) start：开牌，该过程将依照 hand 读写 records，部分扑克牌类型对开牌的 hand 有特定要求；该过程仅允许在 Assigned 状态下进行；调用成功后，状态将变更为 Started 或 Over（开局直接结束游戏）。
7) play：出牌，该过程将依照 hand 读写 records；该过程仅允许在 Started 状态下进行；游戏结束后，状态将变更为 Over。
8) set：导入牌局，该过程将先尝试将参数作为文件路径进行处理，处理失败则将参数作为数据进行处理；该过程仅允许不低于 Initialized 的状态下被调用；调用成功后，状态将根据导入牌局的情况进行自适应变更。
9) display：显示牌局；该过程允许在任何状态下被调用；由于该过程是只读的，故不会发生状态变更。

基类中需要被（部分）派生类重写的子函数：

/* Poker::deal */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | assignDealer | 部分重写 | 需要被斗地主和四人斗地主重写 |

/* Poker::setLandlord */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | nextPlayer | 部分重写 | 需要被三两一重写（禁止回打） |

/* Poker::start */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | checkStarting | 部分重写 | 需要被斗地主和四人斗地主重写（首轮第一手牌必须带有最小的牌） |
| 2 | processHand | 纯虚函数 | 根据每个派生类实现 hand 类型的界定 |
| 3 | processBasis | 部分重写 | 需要被斗地主和四人斗地主重写（实时显示倍数信息） |
| 4 | isOver | 部分重写 | 需要被五瓜皮、七鬼五二一和七鬼五二三重写（牌堆为空且只剩一位玩家时） |
| 5 | computeAmounts | 纯虚函数 | 游戏结束时计算结算信息 |
| 6 | isAbsolutelyLargest | 纯虚函数 | 不同扑克牌类型均有各自的实现 |

/* Poker::play */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | coverLastHand | 纯虚函数 | 不同扑克牌类型均有各自的实现 |

/* Poker::display */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | getBasisString | 部分重写 | 需要被斗地主和四人斗地主重写（需要实时显示倍数信息） |
| 2 | getPreRoundString | 纯虚函数 | 不同扑克牌类型均有不同的预备回合信息展示 |

一般地，除了函数 ``processHand`` 会对 ``hand`` 进行排序并主动清空或修改 ``possibleHands`` 以供二义性牌组作进一步确认外，所有 bool 型函数的返回值为 ``false`` 时，不会对传递为引用的任何参数做任何更改。

编程风格：

1) 代码块排序：头文件 -> 宏（不包含用于类或函数内平台控制的宏） -> 简易类型定义 -> constexpr -> 命名空间 -> 枚举类 -> 结构体 -> 类（成员 -> 私有方法 -> 受保护方法 -> 公有方法）-> 非 main 函数 -> main 函数；
2) 符号绑定：在实现构造函数时将析构函数紧挨着写在构造函数下方，出现虚函数时从前往后依次扫描所有重写该虚函数的函数，此二种情况视为同一符号参与变量排序；
3) 变量排序：从 main 函数开始从上往下进行扫描符号，每出现新符号时依照代码块排序放置在其所属代码块中最后的位置，如新符号与当前符号属于同一代码块，则放置在代码块内当前符号前的最后位置，随后递归地从上往下扫描新符号中的新符号执行相应的操作以完成排序；
4) 最小权限原则：对方法在满足设计需求范围的前提下使用最受限的修饰符，例如使用 const 修饰不对成员做出修改的方法，使用 private 声明私有函数等；
5) 虚函数：虚函数在基类中必须使用 virtual 修饰符，在派生类及派生的派生类中均不使用 virtual 修饰符，重写时必须使用 override 修饰符，作为最后实现时必须带有 final 修饰符。

### 确定性规则

前有代码即证明（Code as proof），现有代码即规则（Code as rules）。

本节将先对与扑克游戏有关的概念下定义，并从计算机实现的角度进行描述，随后对各扑克游戏的游戏规则展开详细描述。

#### 通用概念

在日常生活中，扑克牌（Poker Card）是一种全球流行的纸质游戏**工具**，是扑克游戏（Poker）的**基本实现媒介**，而除扑克游戏外，扑克牌还可用于其它游戏；扑克游戏依赖于扑克牌，是牌类游戏的子集，常见的扑克游戏有斗地主、锄大地、拖拉机（升级）等；一些与扑克牌有关的定义如下。

1) 点数（Point）：扑克牌包含 A（1）、2、3、4、5、6、7、8、9、10、J（11）、Q（12）、K（13）十三个点数。
2) 花色（Suit）：扑克牌包含方块（Diamond）、梅花（Club）、红桃（Heart）和黑桃（Spade）四种花色，其中方块和红桃属于红色花色，梅花和黑桃属于黑色花色。
3) 一张扑克牌（Poker Card）：每一张扑克牌均有正反两面，其中扑克牌的正面被称为牌面，牌面常印有牌面值和各式各样的图案（通常是中心对称的），对于一张普通的扑克牌（不是封面牌或广告牌），竖着持牌时扑克牌的左上角和右下角（必须关于牌面中心中心对称）会清晰地指示该扑克牌的牌面值，并以左上角的信息为准，牌面值包含点数和花色向后两个字段（但在大部分中国语种里通常先念花色再念点数），或直接指示大王（彩色图案）和小王（灰色图案）；同一副扑克牌（有关该定义请参阅下文）中的所有扑克牌的背面应当是一致的，使得人们无法轻而易举地从扑克牌的背面知晓牌面内容。
4) 一副完整的扑克牌（Poker）：一副完整的扑克牌包含 54 张扑克牌，即包含大小王（双王）以及由四种花色与 13 个点数组合而成的 $4 \times 13 = 52$ 张不重复的牌；一副完整的扑克牌通常由配套的扑克牌牌盒进行保护，检查扑克牌完整性时，通常基于花色分类后清点点数以确认每张扑克牌都存在且唯一，并查找大小王确认是否唯一。
5) 一副不含大小王的扑克牌：一副完整的扑克牌去除大小王，即仅包含由四种花色与 13 个点数组合而成的 $4 \times 13 = 52$ 张不重复的牌；人们取一副完整的扑克牌，将大小王放置在一旁以使用一副不含大小王的扑克牌，待扑克游戏结束后，将使用的 52 张扑克牌连同大小王一起放回扑克牌牌盒中。
6) 一副带封面牌和广告牌的扑克牌：除包含一副完整的扑克牌外，一副带封面牌和广告牌的扑克牌还包含一张指示生产厂家信息的封面牌以及若干张广告牌（现实中绝大多数成副的扑克牌不含广告牌），其中，封面牌在日常中常被用于替补某张丢失或损坏的扑克牌；请注意，一些厂商出于宣传目的（如消防宣传、预防艾滋病等）会把宣传内容印在普通扑克牌（含大小王）的牌面上，只要牌面指示了点数和花色（或使用 JOKER 指示了大小王），这些牌均不属于定义上的封面牌或广告牌。

在本目录中，对应的计算机实现如下。

1) 点数：使用 ``typedef unsigned char Point`` 实现点数；为优化复杂度，通过 ``constexpr Point JOKER_POINT = 0;`` 定义大王（Big Joker）、小王（Little Joker）和封面牌（Cover）的点数为 0；广告牌的点数代表广告 ID，一副带封面牌和广告牌的扑克牌最多有 1 张封面牌和 13 张广告牌（事实上，在计算机实现中往往不会用到广告牌）；此处，计算机程序不使用枚举型或其它方式对点数进行限制以便执行加减和索引运算。
2) 花色：使用 ``enum class Suit : unsigned char`` 实现花色；为避免歧义，此处，计算机程序定义小王的花色为 ``Suit::Black``，大王的的花色为 ``Suit::Red``，封面牌、广告牌的花色为 ``Suit::Cover``。
3) 一张扑克牌：使用 ``Struct Card`` 实现一张扑克牌；该结构体包含点数 ``Point point = JOKER_POINT`` 和花色 `` Suit suit = Suit::Cover`` 两个字段，当且仅当点数和花色均相等时认为两张扑克牌相等，该判断通过重载 ``==`` 实现；该结构体提供三个构造函数，即不传递任何参数、仅传递点数参数与传递点数和花色两个参数，构造时，计算机程序将以先点数后花色的方式判定扑克牌的合法性，如不合法则将非法的部分重置为缺省值；此外，计算机程序通过 ``operator const string() const`` 提供从 ``Card`` 转换为 ``const string`` 的转换函数。
4) 一副完整的扑克牌：在一副不含大小王的扑克牌（有关该构建请参阅下文）的基础上追加大小王进行构建，构建完成后保存为 ``vector<Card>``。
5) 一副不含大小王的扑克牌：通过两层循环遍历四种花色与 13 个点数的所有组合构建，构建完成后保存为 ``vector<Card>``。
6) 一副带封面牌和广告牌的扑克牌：未在本目录中使用。

为简化表达，本文档剩余部分所述的“牌”均默认为扑克牌。

一些与扑克游戏有关的定义如下。

1) 扑克游戏规则：扑克游戏规则是指导系统和玩家进行对应扑克游戏的系统性规范，涵盖‌牌具配置、发牌机制、出牌逻辑和胜负判定‌等核心要素‌。
2) 牌局（Game）：牌局，简称“局”，指一次包含发牌、开局、中局、残局和结算等过程的完整的游戏，牌局与牌局之间通常相互独立，部分扑克游戏会根据上一局的输赢来决定下一局的发牌、首位出牌的玩家、主点数或主花色；一般情况下，不允许玩家在牌局进行时中途离开、易位或换人。

2) 大小（Value）：一张扑克牌的大小，由所属扑克游戏的游戏规则而非仅看点数的字面值决定；大小是相对的；一些扑克游戏仅根据点数定义大小，而一些扑克游戏则还需要根据花色来定义大小；为优化多态实现，本程序仅将扑克牌的点数的字面值映射到表示大小的类的实例中。
3) 牌堆（Deck）：还未派发至玩家手上的牌；牌堆通常保持不可见。
4) 牌组：由 0 张、一张或多张扑克牌形成的牌的组合（Combination）；请注意，组合是无序的。
5) 牌型（Type）：通常，一种扑克游戏会设定若干种牌型，并提供相应的牌型规则以供玩家或程序根据牌局所属扑克游戏的牌型规则将一个牌组归类为某一种或几种牌型；在本程序中使用 ``Type`` 定义牌型，为优化复杂度，在本程序中，要不起也属于一种牌型（``Type::Empty``）。
6) 母体和被带的牌：部分扑克游戏支持在某种牌型的基础上进行带牌，基础牌型所对应的牌被定义为母体，所带的牌被定义为被带的牌。
7) 牌向量（``vector<Card>``）：一个牌组被解析为一个合法牌型后，该牌组将按照先母体后被带的牌、先大后小的顺序进行排列，该排列是唯一的，排列完成后牌组将被转换为一个有序的牌向量；请注意，转换所得的牌向量的大小应与对应的原始牌组的大小相等，原始牌组中的元素应与相应牌向量中的元素为一一映射关系。
8) 一手牌（Hand）：如果一个牌组能以一种合法的牌型一次性打出去，则将该牌组称为一手牌；将牌组转换为一手牌时，牌型必须是唯一的；在本程序中，结构体 ``Hand`` 包含玩家、牌向量和牌型三个字段，并使用牌向量的第一个元素（``cards[0]``）指示当前牌型下这手牌的大小，若牌型合法且不为“要不起”，则称该一手牌为非弃权的。
9) 盖过（Cover）：如果当前一手牌能够依照所属扑克游戏的规则大过上一手牌，则称当前一手牌盖过上一手牌；当前一手牌和上一手牌均必须为非弃权的。
10) 二义性：在部分扑克游戏中，一个牌组可以依照其所属扑克游戏的牌型规则被解析为多种合法牌型，我们称此类牌组具有二义性；在玩家选定具有二义性的牌组并选择出牌后，玩家或程序应当通过牌局的上下文（context）来判断该牌组应当属于哪一牌型，否则，打出此牌组的玩家应当声明其所属牌型（或由程序询问），方能轮到下一位有出牌权的玩家选择出（什么）牌或不出。
11) 癞子和鬼牌：部分扑克游戏将一副完整扑克牌中的某（几）张扑克牌作为万能牌以充当其它牌使得其所在的牌组拥有（更多）合法的牌型；请注意，鬼牌不一定是大小王，使用万能牌充当其它牌与在日常生活中使用封面牌或广告牌充当不慎遗失或损毁的扑克牌是两个完全不同的概念。
12) 落地：在日常生活中，某一玩家将要打出的一手牌移动至桌面并将手离开桌面后，若打出的一手牌合法，则认为落地；在计算机程序中，落地通常被称为 ``transaction confirmed``，与棋类游戏不同，落地后无法申请悔牌，如有需要，落地时，计算机程序应当进行系统性记录，必要时可通过区块链等技术更为安全地进行记录。
13) 一个循环：在某一玩家做出决策后，其余具有出牌权的玩家依照出牌顺序各做出了一次决策，此时一个循环完成。
14) 一圈牌：打牌中相继出牌、逐级压制的过程称为一圈牌，一圈牌中可以有人不出牌而过牌；若一个牌局连续两人过牌不出时，该圈结束。
14) 回合：在某一玩家；回合通常又称“轮”，一个回合包含至少一个循环。
15) 出牌记录：指对玩家出牌行为的系统性记载；在日常游戏中，玩家通常仅在桌面上展示已落地的牌而不做系统性记载；本程序使用 ``vector<vector<Hand>>`` 存储以回合为单位的若干手牌作为出牌记录，其中外层 vector 的 [0] 记录预备回合信息，在一个循环内，当其他玩家都要不起时，某一玩家盖过自己的上一手牌的基础上越打越大。

有关扑克游戏中人的定义（请同时参阅有关扑克游戏中牌的定义）：

1) 玩家（Player）：指一场牌局中的选手；在本程序中，玩家仅包含用于指示玩家手上的牌的字段，而通常，一位玩家还应包含玩家名、玩家 ID、积分、段位、头像和肖像等信息，但由于本程序侧重于逻辑实现和解杀，未提供用户界面（User Interface，简称 UI）和额外信息，感兴趣的读者朋友们可以实现 UI 并提交拉取请求（Pull Request，简称 PR）。
2) 过牌：
2) 做出决策：做出是否出牌以及如果出牌出什么牌的决定。
3) 当前玩家（Current Player）：当前需要在有限时间内做出决策的玩家。
4) 出牌顺序：指牌局进行时，玩家用于依照的顺序；在日常游戏中通常按逆时针顺序，符合玩家在游戏中“左进右出”的习惯；在日常游戏中，麻将也通常按逆时针顺序进行出牌，而三两一则通常按顺时针顺序进行出牌；由于本程序未涉及 UI，因而无论是逆时针还是顺时针顺序，在本程序中均以自增和对玩家人数取余的形式来切换当前出牌玩家。
5) 发牌顺序：指发牌过程中，发牌者用于依照的顺序；在日常游戏中通常按逆时针顺序，与出牌顺序保持一致；在日常游戏中，一些玩家通常自己摸牌替代由某一个人或几个人或机器完成发牌，麻将通常按顺时针顺序进行发牌。
6) 出牌权：依照正常的出牌顺序轮到某位玩家进行出牌时，如果该玩家依照所属扑克牌的游戏规则被禁止出牌，则称该玩家没有出牌权。
7) 上下家：若玩家 A 出完牌后依照出牌顺序轮到玩家 B 出牌，则称玩家 A 为玩家 B 的上家，玩家 B 为玩家 A 的下家；上下家一般按照出牌顺序进行定义，与玩家的座位无关，也与是否有出牌（权）无关，但如果提示“没有能过大过上家的牌”时，上家被定义为上一位有实际出牌的玩家。
8) 对家：若一个牌局由 $2n$ 位玩家组成（$n \in \mathbb{N}_+ \land n \geqslant 2$），则从自己开始（不算自己）按出牌顺序数 $n$ 位玩家后所得的玩家即为对家；在日常游戏中，如果玩家按出牌顺序均匀地坐成一圈，对家就是位于自己对面的那位玩家。
9) 发牌者（荷官，Croupier，部分地方亦翻译为 Dealer 但在本存储库中该定义不适用）：负责发牌的人，此人可以不是玩家。
10) 庄家（Dealer）：在本存储库中定义为牌局正式开局时首位出牌的玩家。
11) 赢家和输家：一轮或若干轮牌局结束后，获胜的人被称为赢家（部分地区作“赢长”），输的人被称为输家（部分地区作“输记”）。

在本目录中，对应的计算机实现如下。

1) 扑克游戏规则：通过确定的代码流实现控制，是代码即规则的核心部分。
2) 牌局：在扑克游戏初始化后，通常通过（随机）发牌（``Pokerdeal``）或导入（``set``）

程序在识别本扑克牌类型时，会先捕获其英文，如果英文未能与本存储库所支持的任何扑克游戏匹配，则将所有数字相应地替换为中文再进行识别；以下为本存储库所支持的扑克游戏及其确定性规则和实现说明。

#### 斗地主

此扑克牌使用一副完整的扑克牌，每局玩家人数为 3 人，牌局初始时，程序向每位玩家随机派发 17 张牌，并保留 3 张牌作为底牌（地主牌）。在日常游戏中，玩家应当绕圈而坐，面朝内，发牌者将一副完整的扑克牌以牌面背对玩家的形式地进行随机打乱，并保持牌面背对玩家的形式逐张进行派发（通常按逆时针顺序发牌和出牌），直到牌堆剩余三张牌，该三张牌在地主确定之前保持不可见。

发牌完成后，程序随机选择一位玩家开始选择是否叫地主（在日常游戏中通常在发牌前在牌堆中间随机亮出一张明牌并以被发到明牌的玩家作为首位选择是否叫地主的玩家）， 随后令该玩家的下家和下下家选择是否叫地主或抢地主（）

地主身份分配完成后，玩家被分为两个队伍，即一名玩家为地主（攻击方），剩余两名玩家为农民（防守方），先出完所有牌的玩家所在的队伍获胜。

斗地主支持的牌型如下（与参阅 2) 一致但作出了更详细的解释）：

| 序号 | 牌型 | 代码 | 说明 | 排序 | 注意事项 |
| - | - | - | - | - | - |
| 1 | 单张 | ``Type::Single`` | 任意一张牌 | - | - |
| 2 | 对子 | ``Type::Pair`` | 两张点数相同的牌 | 依照花色降序 | 双王不能算作对子（即使在本程序中大小王的点数均被定义为 0） |
| 3 | 王炸 \| 火箭 | ``Type::PairJokers`` | 大小王组成的牌型 | 依照花色降序 | 只能由大小王组成 |
| 4 | 三张 | ``Type::Triple`` | 三张点数相同的牌 | 依照花色降序 |

牌型比较规则如下：

1) 比较的基础：在牌型比较中，除大小王外，其余牌均以点数大小进行比较，点数大小依次为 2 > A > K > Q > J > 10 > 9 > 8 > 7 > 6 > 5 > 4 > 3，花色不参与比较。
2) 王炸：由大小王组成的牌型，这是最大的牌型，能够盖过任何其它牌型。
3) 炸弹：由四张点数相同的牌组成的牌型，能够盖过除王炸外的任何其它牌型，炸弹与炸弹之间的比较以排序后的第一张牌（索引为 [0]）的大小为准。
4) 其余牌型：仅能盖过同牌型、张数相等且排序后的第一张牌（索引为 [0]）的大小比当前一手牌的排序后的第一张牌（索引为 [0]）的大小小的牌。

参阅：

1) 斗地主规则（出自《象棋百科全书》）：[https://www.xqbase.com/other/landlord.htm](https://www.xqbase.com/other/landlord.htm)；
2) 竞技二打一扑克竞赛规则（出自国家体育总局棋牌运动管理中心）：[https://view.officeapps.live.com/op/view.aspx?src=https%3A%2F%2Fwww.sport.gov.cn%2Fqpzx%2Fn5384%2Fc726699%2Fpart%2F412005.doc&wdOrigin=BROWSELINK](https://view.officeapps.live.com/op/view.aspx?src=https%3A%2F%2Fwww.sport.gov.cn%2Fqpzx%2Fn5384%2Fc726699%2Fpart%2F412005.doc&wdOrigin=BROWSELINK)（请仅参阅牌型规则和牌型比较规则）；
3) 斗地主（维基百科）：[https://zh.wikipedia.org/wiki/%E9%AC%A5%E5%9C%B0%E4%B8%BB](https://zh.wikipedia.org/wiki/%E9%AC%A5%E5%9C%B0%E4%B8%BB)。

#### 斗地主拓展版

除牌型上做出如下变化，其余事宜与斗地主一致。

1) 认为飞机在带翅膀时，允许被带的牌中存在与飞机母体中任意一张牌点数相等的牌，允许被带的牌中含有王炸或炸弹的牌组，例如一手 44433355 视为 444333 + 5 + 5，一手 44443333（可被）视为 444333 + 4 + 3，一手 4443335555 视为 444333 + 55 + 55。
2) 认为四带二单或二对时，允许被带的牌中含有王炸或炸弹的牌组，例如一手 444455 视为 4444 + 5 + 5，一手 55553333 视为 5555 + 33 + 33，一手 44443333 视为 4444 + 33 + 33；当然，44443333 在出牌时，如无法通过牌局的上下文确定其牌型，需由出牌的玩家确定为飞机带小翼还是四带二对。

参阅：支付宝斗地主小程序。

#### 四人斗地主

此扑克牌使用两副完整的扑克牌，每局玩家人数为 4 人。

**1. 发牌和决定地主**

**发牌**：游戏开始后发牌，留 8 张底牌，每人发 25 张牌。

**叫分**：随机选择一个玩家开始依次叫分，玩家可以选择叫“1分”、“2分”、“3分”或者不叫分，所叫的分数必须比上一家高。叫3分的玩家成为地主。如果没有玩家叫3分，则一轮下来叫分最高的玩家成为地主。如果没有任何一个玩家叫分，则重新发牌，三轮都没有人叫地主，则~~解散游戏~~强制首位选择不叫的玩家为地主。

**底牌**：决定地主后，底牌发给成为地主的玩家，~~其他~~所有玩家可见。

**2. 牌型**

**单张**：任意一张单牌；该牌型在本程序中被注释为单牌。
**顺子**：任意五张或者五张以上点数相连的牌；王和 2 不能出现在顺子中。
**对子**：任意两张点数相同的牌；两个小王或两个大王也算对子牌型。
**连对**：三对或三对以上点数相连的牌，如：556677；王和 2 不能出现在连对中。
**三张**：任意三张点数相同的牌；该牌型在本程序中被注释为三条。
**三顺**：两组或两组以上点数相连的三张牌，如：666555、888777666555；王和 2 不能出现在三顺中；该牌型在本程序中被注释为飞机（不带翅膀）。
**三带二**：点数相同的三张牌＋一对牌，如 55577。
**飞机带翅膀**：三顺＋数量与组数相同的对牌，如 777666555＋KKJJ99；任一被带的牌的点数不能等于三顺中的任一点数，被带的牌中不能含有炸弹或天王炸弹；该牌型在本程序中被注释为飞机带大翼。
**炸弹**：四张或四张以上点数相同的牌，如 66666、999999。
**天王炸弹**：四张王牌。

**3. 牌型的比较**

 天王炸弹大于所有其他的牌型。

炸弹牌型大于除天王炸弹外的所有其他牌型。炸弹的牌型相互比较时，牌张数多的大，牌数相同的情况，则比较点数，点数大的炸弹大。

非炸弹的牌型，~~牌型、张数相同才能相互比较，点数大的则大，三带二、飞机带翅膀的牌型比较牌型中张数最多的牌的点数即可。~~当前一手牌的牌型和张数均相同且（``hand.cards[0]`` 的）点数比上一手牌的点数大时才能盖过上一手牌。

点数大小，从大到小依次为：大王、小王、2、A、K、Q、J、10、9、8、7、6、5、4、3。

**4. 胜负条件**

 地主为一队，其他三个玩家为另一队，先出完牌的玩家所属的队伍获胜。

**5. 积分计算**

底分：叫牌的分数，可以叫1分、2分、3分。
倍数：初始为1倍。

一局结束后，基本分的计算方法：

地主胜：地主得分为 3×底分×倍数；其余玩家各得：-底分×倍数。
地主败：地主得分为 -3×底分×倍数；其余玩家各得：底分×倍数。

以下情况，输赢的基本分翻倍（翻倍条件可重叠）：

1) 每打出一个六张牌和七张牌的炸弹，基本分×2；
2) 每打出一个8张牌炸弹和天王炸弹，基本分×3；
3) 地主所有牌出完，其他三家一张都未出，基本分×2；
4) 其他两家中有一家先出完牌，地主只出过一手牌，基本分×2。

除修改了三轮无人叫地主的程序行为、明确了一些牌型规则以及没有玩家的累计积分及其对应的等级信息外，其余事宜与参阅一致。

参阅：腾讯 QQ 游戏四人斗地主（两副牌）规则。

#### 锄大地

除顺子和同花的大小以该手牌中最大的一张为准外，其余规则与参阅 1) 相同。

计分规则中，牌分的计算规则如下，其余规则与参阅 2) 相同。

在本程序中，牌分的计算公式为 $y = f(n) + 50b_S + 30b_H + 20b_C + 10b_D$，其中 $n$ 为剩余的牌的张数，$f(n)$ 的定义如下，若剩余的牌包含黑桃 2，则将 $b_S$ 设为 $1$，否则为 $0$，类似地，$b_H$、$b_C$ 和 $b_D$ 分别对应红桃 2、梅花 2 和方块 2 的存在情况。

$$
f(n) = \begin{cases}
	n & n < 8 \\
	2n & 8 \leqslant n < 10 \\
	3n & 10 \leqslant n < 13 \\
	4n & n = 13
\end{cases}
$$

事实上，为节省时间复杂度，牌局结束计算玩家得分时，常将四位玩家的牌分进行求和并逐一减去玩家各自牌分的四倍来计算。

参阅：

1) 出牌规则参阅于锄大地规则（出自香港中文大学计算机科学与工程学系）：[https://appsrv.cse.cuhk.edu.hk/~cscs/event/oldEventSites/cscup2012/games/6.html](https://appsrv.cse.cuhk.edu.hk/~cscs/event/oldEventSites/cscup2012/games/6.html)。
2) 计分规则参阅于大老二（出自百度百科）：[https://baike.baidu.com/item/%E5%A4%A7%E8%80%81%E4%BA%8C/84472](https://baike.baidu.com/item/%E5%A4%A7%E8%80%81%E4%BA%8C/84472)。

#### 三两一



#### 五瓜皮



#### 七鬼五二一



#### 七鬼五二三

除大小比较变为 7＞大王＞小王＞5＞2＞3＞A＞K＞Q＞J＞10＞9＞8＞6＞4 之外，其余事宜与七鬼五二一一致。

参阅：7鬼523（出自维基百科）：[https://zh.wikipedia.org/wiki/7%E9%AC%BC523](https://zh.wikipedia.org/wiki/7%E9%AC%BC523)
