## Poker

本目录提供扑克游戏可能的实现。

### poker.cpp

这是一个你能打赢，同时支持多种扑克游戏的 C++ 程序。

该代码支持命令行启动，在 Windows 下应当使用 Visual Studio 进行静态编译，在其它平台下可使用 g++ 直接编译，要求编译器最低支持 C++11 标准。

基类成员变量：

```
protected:
	mt19937 seed{}; // 用于存储随机数种子
	string name = "扑克牌"; // 用于存储扑克牌类型
	Values values{}; // 用于存储大小
	vector<vector<Card>> players{}; // 用于存储玩家手上的扑克牌
	vector<Card> deck{}; // 用于存储地主牌或牌堆
	vector<vector<Hand>> records{}; // 用于存储游戏记录
	Player currentPlayer = INVALID_PLAYER, dealer = INVALID_PLAYER; // 分别用于指示当前需要进行操作和首轮第一位出牌的玩家
	Hand lastHand{}; // 用于存储最后一手非空 hand
	vector<Amount> amounts{}; // 用于存储结算信息
	Status status = Status::Ready; // 用于存储状态
```

基类中主要的函数（所有成员函数的返回值类型均为 bool）：

1) 构造函数：初始化随机数种子，派生类的构造函数中应当调用该过程并声明扑克牌类型；该过程仅在实例创建时被调用；调用成功后，状态将变更为缺省值 Ready。
2) 析构函数：该过程仅在实例的销毁阶段被调用；由于实例即将被销毁，状态变更没有意义，故不会发生状态变更。
3) initialize：初始化 values（从 1 开始）和 players，该过程将清空 deck 和 record；该过程允许在不低于 Ready 的状态（可理解为任意状态）下被调用；调用成功后，状态将变更为 Initialized。
4) deal：发牌，该过程将利用随机数种子 seed 向 players 和 deck 随机分配扑克牌并清空 records，随后将预备回合信息写入 records[0]；该过程允许在不低于 Initialized 的状态下被调用；调用成功后，状态将变更为 Dealt（涉及地主信息）或 Assigned（不涉及地主信息）；
5) 一些为获取当前玩家和地主信息设定设立的额外函数：地主信息设定仅允许在 Dealt 状态下涉及地主信息的扑克牌类型中进行；地主信息被写入 records[0] 后，状态将变更为 Assigned。
6) start：开牌，该过程将依照 hand 读写 records，部分扑克牌类型对开牌的 hand 有特定要求；该过程仅允许在 Assigned 状态下进行；调用成功后，状态将变更为 Started 或 Over（开局直接结束游戏）。
7) play：出牌，该过程将依照 hand 读写 records；该过程仅允许在 Started 状态下进行；游戏结束后，状态将变更为 Over。
8) set：导入牌局，该过程将先尝试将参数作为文件路径进行处理，处理失败则将参数作为数据进行处理；该过程仅允许不低于 Initialized 的状态下被调用；调用成功后，状态将根据导入牌局的情况进行自适应变更。
9) display：显示牌局；该过程允许在任何状态下被调用；由于该过程是只读的，故不会发生状态变更。

基类中需要被（部分）派生类重写的子函数：

/* Poker::deal */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | assignDealer | 部分重写 | 需要被斗地主和四人斗地主重写 |

/* Poker::setLandlord */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | nextPlayer | 部分重写 | 需要被三两一重写（禁止回打） |

/* Poker::start */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | checkStarting | 部分重写 | 需要被斗地主和四人斗地主重写（首轮第一手牌必须带有最小的牌） |
| 2 | processHand | 纯虚函数 | 根据每个派生类实现 hand 类型的界定 |
| 3 | processBasis | 部分重写 | 需要被斗地主和四人斗地主重写（实时显示倍数信息） |
| 4 | isOver | 部分重写 | 需要被五瓜皮、七鬼五二一和七鬼五二三重写（牌堆为空且只剩一位玩家时） |
| 5 | computeAmounts | 纯虚函数 | 游戏结束时计算结算信息 |
| 6 | isAbsolutelyLargest | 纯虚函数 | 不同扑克牌类型均有各自的实现 |

/* Poker::play */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | coverLastHand | 纯虚函数 | 不同扑克牌类型均有各自的实现 |

/* Poker::display */

| 序号 | 函数签名 | 重写 | 描述 |
| - | - | - | - |
| 1 | getBasisString | 部分重写 | 需要被斗地主和四人斗地主重写（需要实时显示倍数信息） |
| 2 | getPreRoundString | 纯虚函数 | 不同扑克牌类型均有不同的预备回合信息展示 |

一般地，除了函数 ``processHand`` 会对 ``hand`` 进行排序并主动清空或修改 ``possibleHands`` 以供二义性牌组作进一步确认外，所有 bool 型函数的返回值为 ``false`` 时，不会对传递为引用的任何参数做任何更改。

编程风格：

1) 代码块排序：头文件 -> 宏（不包含用于类或函数内平台控制的宏） -> 简易类型定义 -> constexpr -> 命名空间 -> 枚举类 -> 结构体 -> 类（成员 -> 私有方法 -> 受保护方法 -> 公有方法）-> 非 main 函数 -> main 函数；
2) 符号绑定：在实现构造函数时将析构函数紧挨着写在构造函数下方，出现虚函数时从前往后依次扫描所有重写该虚函数的函数，此二种情况视为同一符号参与变量排序；
3) 变量排序：从 main 函数开始从上往下进行扫描符号，每出现新符号时依照代码块排序放置在其所属代码块中最后的位置，如新符号与当前符号属于同一代码块，则放置在代码块内当前符号前的最后位置，随后递归地从上往下扫描新符号中的新符号执行相应的操作以完成排序；
4) 非 const 的类型定义：不在类型声明时使用 const 修饰符；
5) constexpr：能使用 constexpr 的非系统宏则使用 constexpr；
6) 缺省值：所有变量在声明时均必须指派初始值，该初始值可以为 nullptr；
7) 安全检验：即使可能会十分轻微地牺牲一些性能，仍以函数为最小安全单元做必要的安全检验（例如防止恶意的内存修改导致状态不低于 Dealt 时 ``players`` 为空）；
8) 最小权限原则：对方法在满足设计需求范围的前提下使用最受限的修饰符，例如使用 const 修饰不对成员做出修改的方法，使用 private 声明私有函数等；
9) 虚函数：虚函数在基类中必须使用 virtual 修饰符，在派生类及派生的派生类中均不使用 virtual 修饰符，重写时必须使用 override 修饰符，作为最后实现时必须带有 final 修饰符；
10) 冗余代码：部分代码块使用更多的代码可以换取一定的性能，而使用精炼的代码则可能会牺牲一定的性能，因而允许并在性能和精炼代码之间进行平衡取舍；

### 确定性规则

前有代码即证明（Code as proof），现有代码即规则（Code as rules）。

本节将先对与扑克游戏有关的概念下定义，并从计算机实现的角度进行描述，随后对各扑克游戏的游戏规则展开详细描述。

#### 通用概念

在日常生活中，扑克牌（Poker Card）是一种全球流行的纸质游戏**工具**，是扑克游戏（Poker）的**基本实现媒介**，而除扑克游戏外，扑克牌还可用于其它游戏；扑克游戏依赖于扑克牌，是牌类游戏的子集，常见的扑克游戏有斗地主、锄大地、拖拉机（升级）等；一些与扑克牌有关的定义如下。

1) 点数（Point）：扑克牌包含 A（1）、2、3、4、5、6、7、8、9、10、J（11）、Q（12）、K（13）十三个点数。
2) 花色（Suit）：扑克牌包含方块（Diamond）、梅花（Club）、红桃（Heart）和黑桃（Spade）四种花色，其中方块和红桃属于红色花色，梅花和黑桃属于黑色花色。
3) 一张扑克牌（Poker Card）：每一张扑克牌均有正反两面，其中扑克牌的正面被称为牌面，牌面常印有牌面值和各式各样的图案（通常是中心对称的），对于一张普通的扑克牌（不是封面牌或广告牌），竖着持牌时扑克牌的左上角和右下角（必须关于牌面中心中心对称）会清晰地指示该扑克牌的牌面值，并以左上角的信息为准，牌面值包含点数和花色向后两个字段（但在大部分中国语种里通常先念花色再念点数），或直接指示大王（彩色图案）和小王（灰色图案）；同一副扑克牌（有关该定义请参阅下文）中的所有扑克牌的背面应当是一致的，使得人们无法轻而易举地从扑克牌的背面知晓牌面内容。
4) 一副完整的扑克牌（Poker）：一副完整的扑克牌包含 54 张扑克牌，即包含大小王（双王）以及由四种花色与 13 个点数组合而成的 $4 \times 13 = 52$ 张不重复的牌；一副完整的扑克牌通常由配套的扑克牌牌盒进行保护，检查扑克牌完整性时，通常基于花色分类后清点点数以确认每张扑克牌都存在且唯一，并查找大小王确认是否唯一。
5) 一副不含大小王的扑克牌：一副完整的扑克牌去除大小王，即仅包含由四种花色与 13 个点数组合而成的 $4 \times 13 = 52$ 张不重复的牌；人们取一副完整的扑克牌，将大小王放置在一旁以使用一副不含大小王的扑克牌，待扑克游戏结束后，将使用的 52 张扑克牌连同大小王一起放回扑克牌牌盒中。
6) 一副带封面牌和广告牌的扑克牌：除包含一副完整的扑克牌外，一副带封面牌和广告牌的扑克牌还包含一张指示生产厂家信息的封面牌以及若干张广告牌（现实中绝大多数成副的扑克牌不含广告牌），其中，封面牌在日常中常被用于替补某张不慎遗失或损毁的扑克牌；请注意，一些厂商出于宣传目的（如消防宣传、预防艾滋病等）会把宣传内容印在普通扑克牌（含大小王）的牌面上，只要牌面指示了点数和花色（或使用 JOKER 指示了大小王），这些牌均不属于定义上的封面牌或广告牌。

在本目录中，对应的计算机实现如下。

1) 点数：使用 ``typedef unsigned char Point`` 实现点数；为优化复杂度，通过 ``constexpr Point JOKER_POINT = 0;`` 定义大王（Big Joker）、小王（Little Joker）和封面牌（Cover）的点数为 0；广告牌的点数代表广告 ID，一副带封面牌和广告牌的扑克牌最多有 1 张封面牌和 13 张广告牌（事实上，在计算机实现中往往不会用到广告牌）；此处，计算机程序不使用枚举型或其它方式对点数进行限制以便执行加减和索引运算。
2) 花色：使用 ``enum class Suit : unsigned char`` 实现花色；为避免歧义，此处，计算机程序定义小王的花色为 ``Suit::Black``，大王的的花色为 ``Suit::Red``，封面牌、广告牌的花色为 ``Suit::Cover``。
3) 一张扑克牌：使用 ``Struct Card`` 实现一张扑克牌；该结构体包含点数 ``Point point = JOKER_POINT`` 和花色 `` Suit suit = Suit::Cover`` 两个字段，当且仅当点数和花色均相等时认为两张扑克牌相等，该判断通过重载 ``==`` 实现；该结构体提供三个构造函数，即不传递任何参数、仅传递点数参数与传递点数和花色两个参数，构造时，计算机程序将以先点数后花色的方式判定扑克牌的合法性，如不合法则将非法的部分重置为缺省值；此外，计算机程序通过 ``operator const string() const`` 提供从 ``Card`` 转换为 ``const string`` 的转换函数。
4) 一副完整的扑克牌：在一副不含大小王的扑克牌（有关该构建请参阅下文）的基础上追加大小王进行构建，构建完成后保存为 ``vector<Card>``。
5) 一副不含大小王的扑克牌：通过两层循环遍历四种花色与 13 个点数的所有组合构建，构建完成后保存为 ``vector<Card>``。
6) 一副带封面牌和广告牌的扑克牌：未在本目录中使用过该定义。

为简化表达，本文档剩余部分所述的“牌”均默认为扑克牌。

一些与扑克游戏有关的定义如下。

1) 扑克游戏规则：扑克游戏规则是指导系统和玩家进行对应扑克游戏的系统性规范，涵盖牌具配置、发牌机制、出牌逻辑和胜负结算等核心要素。
2) 牌局（Game）：牌局，简称“局”，指一次包含发牌、预备、开局、中局、残局和结算等过程的完整的游戏，在大多数扑克游戏中，牌局与牌局之间是相互独立的，少部分扑克游戏会根据上一局的情况来决定下一局的事宜；此处，上一局、当前牌局和下一局以同一条牌局线下牌局的发生顺序为参照，而同一条牌局线下的发生顺序通常为时间顺序。
3) 玩家（Player）：玩家，指一场牌局中的选手；当前需要（在有限时间内）做出决策或因不具有出牌权而被跳过的玩家被称为当前玩家（Current Player），其中，做出决策指做出进行实际出牌或放弃当前出牌权（俗称“过牌”“要不起”）的决定；依照出牌顺序（通常为让玩家绕着用于扑克游戏的圆桌或方桌围成一圈的逆时针顺序以符合玩家在扑克游戏中“左进右出”的习惯），上一位和下一位需要（在有限时间内）做出决策或因不具有出牌权而被跳过的玩家通常被分别称为上家和下家，上下家一般仅按出牌顺序进行定义，与玩家的座位无关，也与是否有出牌（权）无关，但在诸如“没有能过大过上家的牌”“怕上家两手走完”“有下家打了”的口头表述中，上下家分别被定义为上一位和下一位有实际出牌的玩家；若一种扑克游戏需要 $2n$ 位玩家参与（$n \in \mathbb{N}_+ \land n \geqslant 2$），则按出牌顺序从某一玩家开始（该玩家的下家为 1）数 $n$ 位玩家后所得的玩家与该玩家互为对家，若玩家按出牌顺序均匀地围坐成一圈，则某一玩家的对家即为位于该玩家对面的那位玩家，对家可以是敌，也可以是友。
4) 发牌者（Croupier）：发牌者，又称“荷官”，指负责发牌的人，此人可以不是玩家，但在日常生活中常因为缺人或嫌麻烦而使用发牌机器进行发牌、让某一或某几位玩家做发牌者进行发牌或让每位玩家自己轮流摸牌替代发牌，部分扑克游戏会根据上一局的输赢来决定当前牌局的发牌者，绝大多数扑克游戏的发牌顺序通常与出牌顺序保持一致（麻将通常按逆时针顺序进行出牌而按顺时针顺序进行发牌），发牌宜在洗匀后逐玩家逐张派发。
5) 庄家（Dealer）：庄家，在一个牌局正式开局时首位出牌的玩家；大部分扑克游戏以拥有单牌价值最小的牌的玩家为庄家，少部分扑克游戏由上一局的输赢决定当前牌局的庄家。
6) 赢家和输家：一轮或若干轮牌局结束后，获胜的人被称为赢家（部分地区作“赢长”），输的人被称为输家（部分地区作“输记”）。
7) 价值（Value）：由所属扑克游戏的游戏规则确定的一张扑克牌牌面值的相对大小，通俗而言，价值就是每一张单牌的大小顺序，一些扑克游戏仅根据点数即可确定价值（同点数不同花色等价），而一些扑克游戏则还需要根据花色来确定价值。
8) 牌堆（Deck）：还未派发至玩家手上的牌；牌堆通常保持不可见。
9) 牌组：由 0 张、一张或多张扑克牌形成的牌的组合（Combination）；请注意，组合是无序的。
10) 牌型（Type）：通常，一种扑克游戏会设定若干种牌型，并提供相应的牌型规则以供玩家或程序根据所属扑克游戏的牌型规则将一个牌组归类为某一种或几种牌型；部分扑克游戏支持在某种牌型的基础上进行带牌形成拓展牌型，基础牌型所对应的牌被定义为主牌（Body Cards），被带的牌被定义为副牌（Side Cards）；当不存在副牌时，认为所有牌均为主牌；不同的扑克游戏支持的牌型可能有所出入，若某一扑克游戏并不支持某一牌型，则称该牌型在该扑克游戏中是非法的；一些牌型在多种扑克游戏中均为合法牌型，但它们的称呼（别称）在不同的扑克游戏或地区中可能有所出入。
11) 单元（Unit）：主牌中点数相同的牌形成一个主牌单元，主牌单元的个数即为主牌的长度（Length），通常用于代理牌型的长度，当每个主牌单元中的牌的数量相等时，一个主牌单元中的牌的数量即为主牌单元的大小；当一个牌型规定副牌中牌的数量必须随着主牌的长度（主牌单元个数）的增减以某一固定正整数斜率呈现正比例增减时，副牌的长度即为主牌的长度，固定的正整数斜率即为副牌单元的大小，此时，一个副牌单元将严格与一个主牌单元形成一一对应关系，一对主牌单元和副牌单元形成一个单元，单元的个数即为牌型的长度，单元的大小即为主牌单元大小与副牌单元大小之和；一些扑克游戏的拓展牌型的副牌的总张数恒定为某个正整数值，这意味着只有一个副牌单元且该副牌单元的大小为该正整数值，此时副牌的长度和主牌的长度没有任何关联；无论是单元还是主牌单元、副牌单元，其价值均有其内部价值最高的扑克牌的价值决定。
12) 一手牌（Hand）：在不考虑上下文的情况下，如果一位玩家所选的一个牌组能以一种合法的牌型一次性打出去，则将该玩家、该牌组和该牌型合并为一手牌；从牌组升变为一手牌时，原本无序的牌组将按照一定的规则被转变为有序的牌向量（vector），一手牌中的玩家和牌型必须是唯一的；两手拥有相同牌型的牌进行比较时，各自的价值均仅由其主牌的价值决定（主牌的价值需参阅具体的扑克游戏规则）；若牌型合法且不为“要不起”，则称该手牌有实际出牌，为非弃权的。
13) 落地：若一手牌（含“要不起”）被确认打出，则称该手牌落地；在日常生活中，某一玩家将要打出的一手牌移动至桌面并将手离开桌面后，若打出的一手牌合法，则认为落地。
14) 盖过（Cover）：如果当前一手牌能够依照所属扑克游戏的规则大过上一手牌，则称当前一手牌盖过上一手牌；部分扑克游戏实行“先牌型后价值”的比较逻辑，部分扑克游戏仅允许相同牌型的情况下让较高价值的一手牌盖过较低价值的上一手牌；当前一手牌和上一手牌必须均有实际出牌，若当前一手牌恰能盖过上一手牌，则称当前一手牌比上一手牌高一级。
15) 二义性（Ambiguity）：在部分扑克游戏中，一个牌组可以依照其所属扑克游戏的牌型规则被解析为多种合法牌型，我们称此类牌组具有二义性；在玩家选定具有二义性的牌组即将落地时，系统或玩家应当通过牌局的上下文（Context）来判断该牌组应当属于哪一牌型，如果二义性依旧存在，打出此牌组的玩家应当声明其所属牌型方能完成落地。
16) 癞子和鬼牌：部分扑克游戏将一副完整扑克牌中的某（几）张扑克牌作为万能牌以充当其它牌使得其所在的牌组拥有（更多）合法的牌型，癞子和鬼牌的使用往往会产生二义性，部分扑克游戏还进一步将癞子分为天癞和地癞；请注意，鬼牌不一定是大小王，使用万能牌充当其它牌与在日常生活中使用封面牌或广告牌充当不慎遗失或损毁的扑克牌是两个完全不同的概念。
17) 一个循环（Loop）：牌局中所有玩家依照出牌顺序均各成为了一次当前玩家标志着一个循环的完成，当前玩家包含拥有出牌权并做出决策和因不具有出牌权而被跳过两种情况。
18) 一圈牌（Circle）：牌局中相继出牌盖过上一手牌的过程称为一圈牌，一圈牌中可以有玩家拥有出牌权但放弃当前出牌权或因不具有出牌权而被跳过；若在一个需要 $n$ 位玩家（$n \in \mathbb{N}_+ \land n \geqslant 2$）的牌局中存在连续 $(n - 1)$ 人过牌不出时，该圈结束；每一圈牌中的第一手牌被称为引牌，一圈牌至少包含一个循环。
19) 一个回合（Round）：一个回合的定义与一圈牌的定义类似，但在一圈牌结束后，若新一圈牌的引牌依旧能够盖过上一圈牌的最后一手牌，则认为该回合没有结束，仅当新一圈牌的引牌无法盖过其上一圈牌的最后一手牌时，该回合结束；回合通常又称“轮”，一个回合至少包含一圈牌；部分扑克游戏在发牌后和开局前存在预备回合。
20) 出牌记录：指对玩家出牌行为的系统性记载；在日常生活中，玩家通常仅在桌面上展示已落地的牌而不做系统性记载。

在本目录中，对应的计算机实现如下。

1) 扑克游戏规则：通过确定的代码流实现控制，是代码即规则的核心部分；本程序使用面向对象编程，基类为 ``Poker``。
2) 牌局：在扑克游戏初始化后，通常通过（随机）发牌（``Pokerdeal``）或导入（``set``）来切换至新的一局。
3) 玩家：通过 ``typedef unsigned char Player`` 实现，由于 ``char`` 占用一字节为计算机程序中最小的对齐单位，可以表示 $2^8 = 256$ 个不同的数值，而所有扑克游戏中玩家人数最多为 10 人，且玩家 ID 不宜为负数，因此选择 ``unsigned char`` 作为 ``Player`` 的数据类型；在本程序中，玩家仅用于指示玩家手上的扑克牌，并使用 ``vector<vector<Card>> players{}`` 表示，以外层索引代表玩家 ID，在输出玩家 ID 到控制台时，通常需要将玩家 ID 加上 1 后输出，而在大多数计算机程序中，一位玩家通常还应包含玩家名、玩家 ID、累计积分、段位、头像和装扮等信息，但由于本程序侧重于逻辑实现和解杀，暂不提供图形用户界面（Graphical User Interface，简称 GUI）和额外信息，因此仅将玩家表示为玩家手上的扑克牌，感兴趣的读者朋友们可以实现 GUI 并提交拉取请求（Pull Request，简称 PR）。
4) 发牌者：通过确定的代码流实现控制。
5) 庄家：通过 ``Player dealer`` 实现，缺省值为 ``constexpr Player INVALID_PLAYER = (Player)(-1)``。
6) 赢家和输家：通过确定的代码流实现控制，当状态变更为 Over 后，若调用成员函数 ``display``，本程序会输出 ``amounts`` 中的内容，部分扑克游戏会在发牌阶段开始读写 ``amounts[0]`` 以记录倍数信息。
7) 价值：通过 ``typedef unsigned char Value`` 实现；为优化多态实现，本程序仅将扑克牌牌面值的点数映射到表示多个价值（``class Values``）的类对象中，每个类对象内部使用类型为 ``Value``、长度为 14 的静态数组进行存储，数组的索引即为点数，索引对应的值即为价值，数组中数值的缺省值为 0，表示未定义；在设置某一点数的价值时，当且仅当 ``0 <= point && point <= 13 && 1 <= value && value <= 14`` 为 ``true`` 时才对数组相应的索引进行写入；在读取某一点数的价值时，当且仅当 ``0 <= point && point <= 13`` 为 ``true`` 时才返回数组相应索引上的价值，否则返回 ``0``；由于 ``char`` 占用一字节为计算机程序中最小的对齐单位，可以表示 $2^8 = 256$ 个不同的数值，而一副完整的扑克牌最多含有 14 个点数（含 ``JOKER_POINT``），对应至多含有 15 个价值数值（0 为未定义），且价值数值为相对的，不宜为负数，因此选择 ``unsigned char`` 作为 ``Value`` 的数据类型。
8) 牌堆：通过 ``vector<Card> deck{}`` 实现，通常在计算机程序将需要用到的所有扑克牌（例如四人斗地主需要两副完整的扑克牌）写入 ``deck`` 后原地将 ``deck`` 打乱，并从后往前批量弹出用于发牌（由于已有的随机过程使得不同的循环嵌套逻辑基本上可认为是等效的因此可直接批量弹出以用于优化时间复杂度）或逐张弹出用于补牌（这与日常生活中将扑克牌倒放在桌面后逐一发出去类似且从后往前弹出对 ``vector`` 更为友好）。
9) 牌组：通过 ``vector<Card> cards{}`` 实现，虽然牌组是无序的，但考虑到存在需要使用多副牌的扑克游戏以及使用原地排序来实现 ``cards`` 的后续升变可以减少复杂度，计算机程序通常直接使用 ``vector`` 进行存储。
10) 牌型：通过 ``enum class Type : unsigned char`` 实现，由于 ``unsigned char`` 占用一字节为计算机程序中最小的对齐单位，可以表示 $2^8 = 256$ 个不同的数值，且认为 ``0b11111111`` 为所能表示的最大的数值，因此选择 ``unsigned char`` 作为 ``Type`` 的数据类型；为优化复杂度，要不起也属于一种牌型（``Type::Empty``），``Type`` 的前四个比特（bit）用于指示主牌中每个单元的大小，后四个比特则在前四个比特的基础上依照习惯枚举符合的牌型，其命名规则与此类似；请注意，每类牌型在不同的扑克游戏中可能存在合法性和称呼（别称）上的差异，但 ``Type`` 类自身不会随着多态的实现而增加、删除或重命名某一个（些）字段，而是做一个统一的枚举，由各派生类在不修改 ``Type`` 类的情况下对牌型做出相应的处理，例如合法性检验、取别名和判断大小。
11) 单元：通过确定的代码流实现控制；返回值为主牌单元长度、用于判断某一牌组是否为顺子的成员函数明显地使用单元这一概念。
12) 一手牌：通过 ``struct Hand`` 实现，包含玩家、牌向量（``vector<Card> cards``）和牌型三个字段，其中，牌向量由牌组先依照牌型按照“先主牌后副牌”的方式排序，再按照主牌单元价值在主牌范围内降序排列所有主牌单元，随后按照副牌单元价值在副牌范围内降序排列所有副牌单元，最后按照“先价值后花色”的顺序对各主牌单元和副牌单元内的扑克牌降序排序而来，该排序是唯一的，除部分特殊的顺子场景外，通过上述排序方式所得牌向量的第一个元素（``cards[0]``）的价值代表该手牌在其牌型下的价值；在已知牌型相同的条件下判断两手牌的牌型长度是否相等时，计算机程序往往直接通过两手牌中牌向量的大小（长度）来完成判断以优化时间复杂度，读者朋友们可通过分类讨论自行证明这与解析后判断牌型或主牌的长度是否相等的结果是一致的；请注意，从牌组转变所得的牌向量的大小应与对应的原始牌组的大小相等，原始牌组中的元素应与所得牌向量中的元素为一一映射关系；当且仅当三个字段的值都相等时认为两个 ``Hand`` 结构体对象相等，该判断通过重载 ``==`` 实现。
13) 落地：在计算机程序中，落地通常被视为一种 ``transaction confirmed``，从玩家手中将相应的牌移走、做出相应的系统性记载并切换当前玩家即为落地；与棋类游戏不同，扑克游戏落地后无法申请悔牌，计算机程序在必要时可通过区块链等技术更为安全地进行系统性记载。
14) 盖过：通过确定的代码流实现控制；盖过时，更新用于指示上一手有实际出牌的牌的成员变量（声明为 ``Hand lastHand{}``），当 ``lastHand`` 满足 ``this->player != INVALID_PLAYER || this->type != Type::Invalid`` 时，说明已有玩家进行过实际出牌。
15) 二义性：通过 ``struct Candidate`` 实现，该结构体包含 ``Hand hand{}`` 和 ``string description{}`` 两个字段；对于已确认存在二义性的牌组，本程序优先通过上下文筛选出潜在的牌型，若此时牌型已唯一，则直接决定牌型、清空传递的 ``vector<Candidate>& candidates`` 参数并返回 ``true``，否则根据 ``candidates`` 参数做出进一步的处理，即，若 ``candidates`` 的大小为 1 且 ``candidates[0].hand`` 位于已筛选出的潜在牌型中，则执行 ``hand = move(candidates[0].hand)`` 并返回 ``true``，否则清空 ``candidates`` 并将剩余的潜在牌型拷贝到 ``candidates`` 后返回 ``false``。
16) 癞子和鬼牌：暂未在本目录中使用过该定义。
17) 一个循环：暂未在本目录中使用过该定义。
18) 一圈牌：暂未在本目录中使用过该定义。
19) 一个回合：通过 ``vector<Hand>`` 实现。
20) 出牌记录：通过 ``vector<vector<Hand>> records{}`` 实现，存储以回合为单位的若干手牌作为出牌记录，其中 ``records[0]`` 记录预备回合的信息。

程序在识别本扑克牌类型时，会先捕获其英文，如果英文未能与本存储库所支持的任何扑克游戏匹配，则将所有数字相应地替换为中文再进行识别；以下为本存储库所支持的扑克游戏及其确定性规则和实现说明。

#### 斗地主

此扑克牌使用一副完整的扑克牌，每局玩家人数为 3 人，牌局初始时，程序向每位玩家随机派发 17 张牌，并保留 3 张牌作为底牌（地主牌）。在日常生活中，玩家应当绕圈而坐，面朝内，发牌者将一副完整的扑克牌以牌面背对玩家的形式地进行随机打乱，并保持牌面背对玩家的形式逐张进行派发（通常按逆时针顺序发牌和出牌），直到牌堆剩余三张牌，该三张牌在地主确定之前保持不可见。

发牌完成后，程序随机选择一位玩家开始选择是否叫地主（在日常生活中通常在发牌前在牌堆中间随机亮出一张明牌并以被发到明牌的玩家作为首位选择是否叫地主的玩家）， 随后令该玩家的下家和下下家选择是否叫地主或抢地主（）

地主身份分配完成后，玩家被分为两个队伍，即一名玩家为地主（攻击方），剩余两名玩家为农民（防守方），先出完所有牌的玩家所在的队伍获胜。

斗地主支持的牌型如下（与参阅 2) 一致但作出了更详细的解释）：

| 序号 | 牌型 | 代码 | 说明 | 排序 | 注意事项 |
| - | - | - | - | - | - |
| 1 | 单张 | ``Type::Single`` | 任意一张牌 | - | - |
| 2 | 对子 | ``Type::Pair`` | 两张点数相同的牌 | 依照花色降序 | 双王不能算作对子（即使在本程序中大小王的点数均被定义为 0） |
| 3 | 王炸 \| 火箭 | ``Type::PairJokers`` | 大小王组成的牌型 | 依照花色降序 | 只能由大小王组成 |
| 4 | 三张 | ``Type::Triple`` | 三张点数相同的牌 | 依照花色降序 |

牌型比较规则如下：

1) 比较的基础：在牌型比较中，除大小王外，其余牌均以点数大小进行比较，点数大小依次为 2 > A > K > Q > J > 10 > 9 > 8 > 7 > 6 > 5 > 4 > 3，花色不参与比较。
2) 王炸：由大小王组成的牌型，这是最大的牌型，能够盖过任何其它牌型。
3) 炸弹：由四张点数相同的牌组成的牌型，能够盖过除王炸外的任何其它牌型，炸弹与炸弹之间的比较以排序后的第一张牌（索引为 [0]）的大小为准。
4) 其余牌型：仅能盖过同牌型、张数相等且排序后的第一张牌（索引为 [0]）的大小比当前一手牌的排序后的第一张牌（索引为 [0]）的大小小的牌。

参阅：

1) 斗地主规则（出自《象棋百科全书》）：[https://www.xqbase.com/other/landlord.htm](https://www.xqbase.com/other/landlord.htm)；
2) 竞技二打一扑克竞赛规则（出自国家体育总局棋牌运动管理中心）：[https://view.officeapps.live.com/op/view.aspx?src=https%3A%2F%2Fwww.sport.gov.cn%2Fqpzx%2Fn5384%2Fc726699%2Fpart%2F412005.doc&wdOrigin=BROWSELINK](https://view.officeapps.live.com/op/view.aspx?src=https%3A%2F%2Fwww.sport.gov.cn%2Fqpzx%2Fn5384%2Fc726699%2Fpart%2F412005.doc&wdOrigin=BROWSELINK)（请仅参阅牌型规则和牌型比较规则）；
3) 斗地主（维基百科）：[https://zh.wikipedia.org/wiki/%E9%AC%A5%E5%9C%B0%E4%B8%BB](https://zh.wikipedia.org/wiki/%E9%AC%A5%E5%9C%B0%E4%B8%BB)。

#### 斗地主拓展版

除牌型上做出如下变化，其余事宜与斗地主一致。

1) 认为飞机在带翅膀时，允许被带的牌中存在与飞机母体中任意一张牌点数相等的牌，允许被带的牌中含有王炸或炸弹的牌组，例如一手 44433355 视为 444333 + 5 + 5，一手 44443333（可被）视为 444333 + 4 + 3，一手 4443335555 视为 444333 + 55 + 55。
2) 认为四带二单或二对时，允许被带的牌中含有王炸或炸弹的牌组，例如一手 444455 视为 4444 + 5 + 5，一手 55553333 视为 5555 + 33 + 33，一手 44443333 视为 4444 + 33 + 33；当然，44443333 在出牌时，如无法通过牌局的上下文确定其牌型，需由出牌的玩家确定为飞机带小翼还是四带二对。

参阅：支付宝斗地主小程序。

#### 四人斗地主

此扑克牌使用两副完整的扑克牌，每局玩家人数为 4 人。

**1. 发牌和决定地主**

**发牌**：游戏开始后发牌，留 8 张底牌，每人发 25 张牌。

**叫分**：随机选择一个玩家开始依次叫分，玩家可以选择叫“1分”、“2分”、“3分”或者不叫分，所叫的分数必须比上一家高。叫3分的玩家成为地主。如果没有玩家叫3分，则一轮下来叫分最高的玩家成为地主。如果没有任何一个玩家叫分，则重新发牌，三轮都没有人叫地主，则~~解散游戏~~强制首位选择不叫的玩家为地主。

**底牌**：决定地主后，底牌发给成为地主的玩家，~~其他~~所有玩家可见。

**2. 牌型**

**单张**：任意一张单牌；该牌型在本程序中被注释为单牌。
**顺子**：任意五张或者五张以上点数相连的牌；王和 2 不能出现在顺子中。
**对子**：任意两张点数相同的牌；两个小王或两个大王也算对子牌型。
**连对**：三对或三对以上点数相连的牌，如：556677；王和 2 不能出现在连对中。
**三张**：任意三张点数相同的牌；该牌型在本程序中被注释为三条。
**三顺**：两组或两组以上点数相连的三张牌，如：666555、888777666555；王和 2 不能出现在三顺中；该牌型在本程序中被注释为飞机（不带翅膀）。
**三带二**：点数相同的三张牌＋一对牌，如 55577。
**飞机带翅膀**：三顺＋数量与组数相同的对牌，如 777666555＋KKJJ99；任一被带的牌的点数不能等于三顺中的任一点数，被带的牌中不能含有炸弹或天王炸弹；该牌型在本程序中被注释为飞机带大翼。
**炸弹**：四张或四张以上点数相同的牌，如 66666、999999。
**天王炸弹**：四张王牌。

**3. 牌型的比较**

 天王炸弹大于所有其他的牌型。

炸弹牌型大于除天王炸弹外的所有其他牌型。炸弹的牌型相互比较时，牌张数多的大，牌数相同的情况，则比较点数，点数大的炸弹大。

非炸弹的牌型，~~牌型、张数相同才能相互比较，点数大的则大，三带二、飞机带翅膀的牌型比较牌型中张数最多的牌的点数即可。~~当前一手牌的牌型和张数均相同且（``hand.cards[0]`` 的）点数比上一手牌的点数大时才能盖过上一手牌。

点数大小，从大到小依次为：大王、小王、2、A、K、Q、J、10、9、8、7、6、5、4、3。

**4. 胜负条件**

 地主为一队，其他三个玩家为另一队，先出完牌的玩家所属的队伍获胜。

**5. 积分计算**

底分：叫牌的分数，可以叫1分、2分、3分。
倍数：初始为1倍。

一局结束后，基本分的计算方法：

地主胜：地主得分为 3×底分×倍数；其余玩家各得：-底分×倍数。
地主败：地主得分为 -3×底分×倍数；其余玩家各得：底分×倍数。

以下情况，输赢的基本分翻倍（翻倍条件可重叠）：

1) 每打出一个六张牌和七张牌的炸弹，基本分×2；
2) 每打出一个8张牌炸弹和天王炸弹，基本分×3；
3) 地主所有牌出完，其他三家一张都未出，基本分×2；
4) 其他两家中有一家先出完牌，地主只出过一手牌，基本分×2。

除修改了三轮无人叫地主的程序行为、明确了一些牌型规则以及没有玩家的累计积分及其对应的等级信息外，其余事宜与参阅一致。

参阅：腾讯 QQ 游戏四人斗地主（两副牌）规则。

#### 锄大地

除顺子和同花的大小以该手牌中最大的一张为准外，其余规则与参阅 1) 相同。

计分规则中，牌分的计算规则如下，其余规则与参阅 2) 相同。

在本程序中，牌分的计算公式为 $y = f(n) + 50b_S + 30b_H + 20b_C + 10b_D$，其中 $n$ 为剩余的牌的张数，$f(n)$ 的定义如下，若剩余的牌包含黑桃 2，则将 $b_S$ 设为 $1$，否则为 $0$，类似地，$b_H$、$b_C$ 和 $b_D$ 分别对应红桃 2、梅花 2 和方块 2 的存在情况。

$$
f(n) = \begin{cases}
	n & n < 8 \\
	2n & 8 \leqslant n < 10 \\
	3n & 10 \leqslant n < 13 \\
	4n & n = 13
\end{cases}
$$

事实上，为节省时间复杂度，牌局结束计算玩家得分时，常将四位玩家的牌分进行求和并逐一减去玩家各自牌分的四倍来计算。

参阅：

1) 出牌规则参阅于锄大地规则（出自香港中文大学计算机科学与工程学系）：[https://appsrv.cse.cuhk.edu.hk/~cscs/event/oldEventSites/cscup2012/games/6.html](https://appsrv.cse.cuhk.edu.hk/~cscs/event/oldEventSites/cscup2012/games/6.html)。
2) 计分规则参阅于大老二（出自百度百科）：[https://baike.baidu.com/item/%E5%A4%A7%E8%80%81%E4%BA%8C/84472](https://baike.baidu.com/item/%E5%A4%A7%E8%80%81%E4%BA%8C/84472)。

#### 三两一



#### 五瓜皮



#### 七鬼五二一



#### 七鬼五二三

除大小比较变为 7＞大王＞小王＞5＞2＞3＞A＞K＞Q＞J＞10＞9＞8＞6＞4 之外，其余事宜与七鬼五二一一致。

参阅：7鬼523（出自维基百科）：[https://zh.wikipedia.org/wiki/7%E9%AC%BC523](https://zh.wikipedia.org/wiki/7%E9%AC%BC523)
